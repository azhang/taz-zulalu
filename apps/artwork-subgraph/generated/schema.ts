// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import { TypedMap, Entity, Value, ValueKind, store, Bytes, BigInt, BigDecimal } from "@graphprotocol/graph-ts"

export class Token extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save Token entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.STRING,
                `Entities of type Token must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("Token", id.toString(), this)
        }
    }

    static load(id: string): Token | null {
        return changetype<Token | null>(store.get("Token", id))
    }

    get id(): string {
        let value = this.get("id")
        return value!.toString()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get tokenId(): BigInt {
        let value = this.get("tokenId")
        return value!.toBigInt()
    }

    set tokenId(value: BigInt) {
        this.set("tokenId", Value.fromBigInt(value))
    }

    get uri(): string {
        let value = this.get("uri")
        return value!.toString()
    }

    set uri(value: string) {
        this.set("uri", Value.fromString(value))
    }

    get imageId(): string {
        let value = this.get("imageId")
        return value!.toString()
    }

    set imageId(value: string) {
        this.set("imageId", Value.fromString(value))
    }

    get hasViolation(): boolean {
        let value = this.get("hasViolation")
        return value!.toBoolean()
    }

    set hasViolation(value: boolean) {
        this.set("hasViolation", Value.fromBoolean(value))
    }

    get totalVotes(): i32 {
        let value = this.get("totalVotes")
        return value!.toI32()
    }

    set totalVotes(value: i32) {
        this.set("totalVotes", Value.fromI32(value))
    }

    get timestamp(): BigInt {
        let value = this.get("timestamp")
        return value!.toBigInt()
    }

    set timestamp(value: BigInt) {
        this.set("timestamp", Value.fromBigInt(value))
    }

    get violations(): Array<string> | null {
        let value = this.get("violations")
        if (!value || value.kind == ValueKind.NULL) {
            return null
        } else {
            return value.toStringArray()
        }
    }

    set violations(value: Array<string> | null) {
        if (!value) {
            this.unset("violations")
        } else {
            this.set("violations", Value.fromStringArray(<Array<string>>value))
        }
    }

    get votes(): Array<string> | null {
        let value = this.get("votes")
        if (!value || value.kind == ValueKind.NULL) {
            return null
        } else {
            return value.toStringArray()
        }
    }

    set votes(value: Array<string> | null) {
        if (!value) {
            this.unset("votes")
        } else {
            this.set("votes", Value.fromStringArray(<Array<string>>value))
        }
    }
}

export class Violation extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save Violation entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.STRING,
                `Entities of type Violation must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("Violation", id.toString(), this)
        }
    }

    static load(id: string): Violation | null {
        return changetype<Violation | null>(store.get("Violation", id))
    }

    get id(): string {
        let value = this.get("id")
        return value!.toString()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get reviewer(): Bytes {
        let value = this.get("reviewer")
        return value!.toBytes()
    }

    set reviewer(value: Bytes) {
        this.set("reviewer", Value.fromBytes(value))
    }

    get timestamp(): BigInt {
        let value = this.get("timestamp")
        return value!.toBigInt()
    }

    set timestamp(value: BigInt) {
        this.set("timestamp", Value.fromBigInt(value))
    }

    get token(): string {
        let value = this.get("token")
        return value!.toString()
    }

    set token(value: string) {
        this.set("token", Value.fromString(value))
    }
}

export class Vote extends Entity {
    constructor(id: string) {
        super()
        this.set("id", Value.fromString(id))
    }

    save(): void {
        let id = this.get("id")
        assert(id != null, "Cannot save Vote entity without an ID")
        if (id) {
            assert(
                id.kind == ValueKind.STRING,
                `Entities of type Vote must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
            )
            store.set("Vote", id.toString(), this)
        }
    }

    static load(id: string): Vote | null {
        return changetype<Vote | null>(store.get("Vote", id))
    }

    get id(): string {
        let value = this.get("id")
        return value!.toString()
    }

    set id(value: string) {
        this.set("id", Value.fromString(value))
    }

    get timestamp(): BigInt {
        let value = this.get("timestamp")
        return value!.toBigInt()
    }

    set timestamp(value: BigInt) {
        this.set("timestamp", Value.fromBigInt(value))
    }

    get token(): string {
        let value = this.get("token")
        return value!.toString()
    }

    set token(value: string) {
        this.set("token", Value.fromString(value))
    }
}
